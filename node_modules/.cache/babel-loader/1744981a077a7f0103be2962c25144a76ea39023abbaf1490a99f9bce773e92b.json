{"ast":null,"code":"// gameActions.js\nimport { mockApi } from \"../../utils/mockApi\";\nexport const getBoard = gameId => async dispatch => {\n  try {\n    const playerPromise = await mockApi.getPlayer(gameId);\n    const monsterPromise = await mockApi.getMonster(gameId);\n    const gamePromise = await mockApi.getGame(gameId);\n    const playerCardPromise = await mockApi.getPlayerCards(playerPromise.data.id);\n    const game = gamePromise.data;\n    const player = playerPromise.data;\n    const monster = monsterPromise.data;\n    const playerCards = playerCardPromise.data;\n    dispatch({\n      type: \"GAME_DATA\",\n      payload: {\n        gameInfo: game,\n        playerInfo: player,\n        monsterInfo: monster,\n        playerCards: playerCards\n      }\n    });\n  } catch (error) {\n    console.log(error.message);\n  }\n};\nexport const nextTurn = (cardId, gameId) => async (dispatch, getState) => {\n  const state = getState().game;\n  let {\n    playerInfo,\n    monsterInfo,\n    gameInfo,\n    playerCards\n  } = state;\n\n  // Apply card effect\n  if (cardId) {\n    const card = playerCards.find(c => c.id === cardId);\n    if (card) {\n      if (card.effect === \"DAMAGE\") {\n        monsterInfo = {\n          ...monsterInfo,\n          hp: Math.max(0, monsterInfo.hp - card.value)\n        };\n      } else if (card.effect === \"HEAL\") {\n        playerInfo = {\n          ...playerInfo,\n          hp: Math.min(playerInfo.maxHp, playerInfo.hp + card.value)\n        };\n      } else if (card.effect === \"SHIELD\") {\n        playerInfo = {\n          ...playerInfo,\n          shield: playerInfo.shield + card.value\n        };\n      }\n    }\n  }\n\n  // Advance turn\n  gameInfo = {\n    ...gameInfo,\n    currentTurn: gameInfo.currentTurn + 1,\n    turnsLeft: gameInfo.turnsLeft - 1\n  };\n\n  // Fake monster effect from API\n  const {\n    data\n  } = await mockApi.nextTurn(gameId, cardId);\n  dispatch({\n    type: \"NEXT_TURN\",\n    payload: {\n      gameInfo,\n      playerInfo,\n      monsterInfo,\n      playerCards,\n      monsterEffect: data.monsterEffect\n    }\n  });\n};\nexport const NewGame = name => async dispatch => {\n  try {\n    const res = await mockApi.newGame(name);\n    dispatch(getBoard(res.data.id));\n  } catch (e) {\n    console.log(e.message);\n  }\n};","map":{"version":3,"names":["mockApi","getBoard","gameId","dispatch","playerPromise","getPlayer","monsterPromise","getMonster","gamePromise","getGame","playerCardPromise","getPlayerCards","data","id","game","player","monster","playerCards","type","payload","gameInfo","playerInfo","monsterInfo","error","console","log","message","nextTurn","cardId","getState","state","card","find","c","effect","hp","Math","max","value","min","maxHp","shield","currentTurn","turnsLeft","monsterEffect","NewGame","name","res","newGame","e"],"sources":["/Users/eri/adventureTime/src/store/actions/index.js"],"sourcesContent":["// gameActions.js\nimport { mockApi } from \"../../utils/mockApi\";\n\nexport const getBoard = (gameId) => async (dispatch) => {\n  try {\n    const playerPromise = await mockApi.getPlayer(gameId);\n    const monsterPromise = await mockApi.getMonster(gameId);\n    const gamePromise = await mockApi.getGame(gameId);\n    const playerCardPromise = await mockApi.getPlayerCards(playerPromise.data.id);\n\n    const game = gamePromise.data;\n    const player = playerPromise.data;\n    const monster = monsterPromise.data;\n    const playerCards = playerCardPromise.data;\n\n    dispatch({\n      type: \"GAME_DATA\",\n      payload: {\n        gameInfo: game,\n        playerInfo: player,\n        monsterInfo: monster,\n        playerCards: playerCards,\n      },\n    });\n  } catch (error) {\n    console.log(error.message);\n  }\n};\n\nexport const nextTurn = (cardId, gameId) => async (dispatch, getState) => {\n  const state = getState().game;\n  let { playerInfo, monsterInfo, gameInfo, playerCards } = state;\n\n  // Apply card effect\n  if (cardId) {\n    const card = playerCards.find((c) => c.id === cardId);\n\n    if (card) {\n      if (card.effect === \"DAMAGE\") {\n        monsterInfo = {\n          ...monsterInfo,\n          hp: Math.max(0, monsterInfo.hp - card.value),\n        };\n      } else if (card.effect === \"HEAL\") {\n        playerInfo = {\n          ...playerInfo,\n          hp: Math.min(playerInfo.maxHp, playerInfo.hp + card.value),\n        };\n      } else if (card.effect === \"SHIELD\") {\n        playerInfo = {\n          ...playerInfo,\n          shield: playerInfo.shield + card.value,\n        };\n      }\n    }\n  }\n\n  // Advance turn\n  gameInfo = {\n    ...gameInfo,\n    currentTurn: gameInfo.currentTurn + 1,\n    turnsLeft: gameInfo.turnsLeft - 1,\n  };\n\n  // Fake monster effect from API\n  const { data } = await mockApi.nextTurn(gameId, cardId);\n\n  dispatch({\n    type: \"NEXT_TURN\",\n    payload: {\n      gameInfo,\n      playerInfo,\n      monsterInfo,\n      playerCards,\n      monsterEffect: data.monsterEffect,\n    },\n  });\n};\n\nexport const NewGame = (name) => async (dispatch) => {\n  try {\n    const res = await mockApi.newGame(name);\n    dispatch(getBoard(res.data.id));\n  } catch (e) {\n    console.log(e.message);\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}