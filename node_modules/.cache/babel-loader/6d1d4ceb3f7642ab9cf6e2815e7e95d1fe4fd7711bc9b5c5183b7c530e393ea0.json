{"ast":null,"code":"// gameActions.js\nimport { mockApi } from \"../../utils/mockApi\";\nexport const getBoard = gameId => async dispatch => {\n  try {\n    const playerPromise = await mockApi.getPlayer(gameId);\n    const monsterPromise = await mockApi.getMonster(gameId);\n    const gamePromise = await mockApi.getGame(gameId);\n    const playerCardPromise = await mockApi.getPlayerCards(playerPromise.data.id);\n    const game = gamePromise.data;\n    const player = playerPromise.data;\n    const monster = monsterPromise.data;\n    const playerCards = playerCardPromise.data;\n    dispatch({\n      type: \"GAME_DATA\",\n      payload: {\n        gameInfo: game,\n        playerInfo: player,\n        monsterInfo: monster,\n        playerCards: playerCards\n      }\n    });\n  } catch (error) {\n    console.log(error.message);\n  }\n};\nexport const nextTurn = cardId => (dispatch, getState) => {\n  const state = getState().game;\n  const {\n    playerCards,\n    monsterInfo\n  } = state;\n\n  // Find the played card\n  const card = playerCards.find(c => c.id === cardId);\n  if (!card) return;\n\n  // Apply card effect (basic mock: damage monster)\n  let newMonster = {\n    ...monsterInfo\n  };\n  if (card.effect === \"damage\") {\n    newMonster.hp = Math.max(0, monsterInfo.hp - card.value);\n  } else if (card.effect === \"heal\") {\n    // you can add heal logic for player here\n  }\n\n  // Remove the used card from hand\n  const newCards = playerCards.filter(c => c.id !== cardId);\n  dispatch({\n    type: \"NEXT_TURN\",\n    payload: {\n      monsterInfo: newMonster,\n      playerCards: newCards\n    }\n  });\n};\nexport const NewGame = name => async dispatch => {\n  try {\n    const res = await mockApi.newGame(name);\n    dispatch(getBoard(res.data.id));\n  } catch (e) {\n    console.log(e.message);\n  }\n};","map":{"version":3,"names":["mockApi","getBoard","gameId","dispatch","playerPromise","getPlayer","monsterPromise","getMonster","gamePromise","getGame","playerCardPromise","getPlayerCards","data","id","game","player","monster","playerCards","type","payload","gameInfo","playerInfo","monsterInfo","error","console","log","message","nextTurn","cardId","getState","state","card","find","c","newMonster","effect","hp","Math","max","value","newCards","filter","NewGame","name","res","newGame","e"],"sources":["/Users/eri/adventureTime/src/store/actions/index.js"],"sourcesContent":["// gameActions.js\nimport { mockApi } from \"../../utils/mockApi\";\n\nexport const getBoard = (gameId) => async (dispatch) => {\n  try {\n    const playerPromise = await mockApi.getPlayer(gameId);\n    const monsterPromise = await mockApi.getMonster(gameId);\n    const gamePromise = await mockApi.getGame(gameId);\n    const playerCardPromise = await mockApi.getPlayerCards(playerPromise.data.id);\n\n    const game = gamePromise.data;\n    const player = playerPromise.data;\n    const monster = monsterPromise.data;\n    const playerCards = playerCardPromise.data;\n\n    dispatch({\n      type: \"GAME_DATA\",\n      payload: {\n        gameInfo: game,\n        playerInfo: player,\n        monsterInfo: monster,\n        playerCards: playerCards,\n      },\n    });\n  } catch (error) {\n    console.log(error.message);\n  }\n};\n\nexport const nextTurn = (cardId) => (dispatch, getState) => {\n    const state = getState().game;\n    const { playerCards, monsterInfo } = state;\n  \n    // Find the played card\n    const card = playerCards.find(c => c.id === cardId);\n    if (!card) return;\n  \n    // Apply card effect (basic mock: damage monster)\n    let newMonster = { ...monsterInfo };\n    if (card.effect === \"damage\") {\n      newMonster.hp = Math.max(0, monsterInfo.hp - card.value);\n    } else if (card.effect === \"heal\") {\n      // you can add heal logic for player here\n    }\n  \n    // Remove the used card from hand\n    const newCards = playerCards.filter(c => c.id !== cardId);\n  \n    dispatch({\n      type: \"NEXT_TURN\",\n      payload: {\n        monsterInfo: newMonster,\n        playerCards: newCards\n      }\n    });\n  };\n\nexport const NewGame = (name) => async (dispatch) => {\n  try {\n    const res = await mockApi.newGame(name);\n    dispatch(getBoard(res.data.id));\n  } catch (e) {\n    console.log(e.message);\n  }\n};\n"],"mappings":"AAAA;AACA,SAASA,OAAO,QAAQ,qBAAqB;AAE7C,OAAO,MAAMC,QAAQ,GAAIC,MAAM,IAAK,MAAOC,QAAQ,IAAK;EACtD,IAAI;IACF,MAAMC,aAAa,GAAG,MAAMJ,OAAO,CAACK,SAAS,CAACH,MAAM,CAAC;IACrD,MAAMI,cAAc,GAAG,MAAMN,OAAO,CAACO,UAAU,CAACL,MAAM,CAAC;IACvD,MAAMM,WAAW,GAAG,MAAMR,OAAO,CAACS,OAAO,CAACP,MAAM,CAAC;IACjD,MAAMQ,iBAAiB,GAAG,MAAMV,OAAO,CAACW,cAAc,CAACP,aAAa,CAACQ,IAAI,CAACC,EAAE,CAAC;IAE7E,MAAMC,IAAI,GAAGN,WAAW,CAACI,IAAI;IAC7B,MAAMG,MAAM,GAAGX,aAAa,CAACQ,IAAI;IACjC,MAAMI,OAAO,GAAGV,cAAc,CAACM,IAAI;IACnC,MAAMK,WAAW,GAAGP,iBAAiB,CAACE,IAAI;IAE1CT,QAAQ,CAAC;MACPe,IAAI,EAAE,WAAW;MACjBC,OAAO,EAAE;QACPC,QAAQ,EAAEN,IAAI;QACdO,UAAU,EAAEN,MAAM;QAClBO,WAAW,EAAEN,OAAO;QACpBC,WAAW,EAAEA;MACf;IACF,CAAC,CAAC;EACJ,CAAC,CAAC,OAAOM,KAAK,EAAE;IACdC,OAAO,CAACC,GAAG,CAACF,KAAK,CAACG,OAAO,CAAC;EAC5B;AACF,CAAC;AAED,OAAO,MAAMC,QAAQ,GAAIC,MAAM,IAAK,CAACzB,QAAQ,EAAE0B,QAAQ,KAAK;EACxD,MAAMC,KAAK,GAAGD,QAAQ,CAAC,CAAC,CAACf,IAAI;EAC7B,MAAM;IAAEG,WAAW;IAAEK;EAAY,CAAC,GAAGQ,KAAK;;EAE1C;EACA,MAAMC,IAAI,GAAGd,WAAW,CAACe,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACpB,EAAE,KAAKe,MAAM,CAAC;EACnD,IAAI,CAACG,IAAI,EAAE;;EAEX;EACA,IAAIG,UAAU,GAAG;IAAE,GAAGZ;EAAY,CAAC;EACnC,IAAIS,IAAI,CAACI,MAAM,KAAK,QAAQ,EAAE;IAC5BD,UAAU,CAACE,EAAE,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEhB,WAAW,CAACc,EAAE,GAAGL,IAAI,CAACQ,KAAK,CAAC;EAC1D,CAAC,MAAM,IAAIR,IAAI,CAACI,MAAM,KAAK,MAAM,EAAE;IACjC;EAAA;;EAGF;EACA,MAAMK,QAAQ,GAAGvB,WAAW,CAACwB,MAAM,CAACR,CAAC,IAAIA,CAAC,CAACpB,EAAE,KAAKe,MAAM,CAAC;EAEzDzB,QAAQ,CAAC;IACPe,IAAI,EAAE,WAAW;IACjBC,OAAO,EAAE;MACPG,WAAW,EAAEY,UAAU;MACvBjB,WAAW,EAAEuB;IACf;EACF,CAAC,CAAC;AACJ,CAAC;AAEH,OAAO,MAAME,OAAO,GAAIC,IAAI,IAAK,MAAOxC,QAAQ,IAAK;EACnD,IAAI;IACF,MAAMyC,GAAG,GAAG,MAAM5C,OAAO,CAAC6C,OAAO,CAACF,IAAI,CAAC;IACvCxC,QAAQ,CAACF,QAAQ,CAAC2C,GAAG,CAAChC,IAAI,CAACC,EAAE,CAAC,CAAC;EACjC,CAAC,CAAC,OAAOiC,CAAC,EAAE;IACVtB,OAAO,CAACC,GAAG,CAACqB,CAAC,CAACpB,OAAO,CAAC;EACxB;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}